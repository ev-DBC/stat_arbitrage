<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>READMEHTMLSWAG</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html">          <title>READMEHTMLSWAG.html</title>        <div class="stackedit__html"> <title>READMEHTMLSWAG</title> <div class="stackedit__html"><h1 id="project-functions-explanation">Tools library</h1> <h2 id="function-list">Indice</h2> <ul> <li><a href="#rightdays"><code>rightdays</code></a></li> <li><a href="#righthoursIS"><code>righthoursIS</code></a></li> <li><a href="#righthoursOS"><code>righthoursOS</code></a></li> <li><a href="#logratio"><code>logratio</code></a></li> <li><a href="#outliercheck"><code>outliercheck</code></a></li> <li><a href="#MLE_estimator"><code>MLE_estimator</code></a></li> <li><a href="#costs"><code>costs</code></a></li> <li><a href="#handle"> Functions section </a></li> <li><a href="#long_run"> <code>long_run</code></a></li> <li><a href="#generateOU"> <code>generateOU</code></a></li> <li><a href="#statisticalbootstrap"> <code>statisticalbootstrap</code></a></li> <li><a href="#tradingStrategy"> <code>tradingStrategy</code></a></li> </ul> <h2 id="functions-explanation">Descrizione funzioni</h2> <ul> <li><p><span id="rightdays"><code>rightdays (df, time_shift, datesIS, datesOS)</code></span> <br> Questa funzione seziona il dataset in In Sample e Out of Sample prendendo in input le date di inizio e di fine dei due campioni. <br> <strong>Inputs</strong>: <br> - <em>df</em>: dataframe <br> - <em>time_shift</em>: valore numerico per ottenere le date corrette <br> - <em>datesIS</em>: date di inizio e fine di IS <br> - <em>datesOS</em>: date di inizio e fine di OS <br> <strong>Outputs</strong>: <br> - <em>[IS, OS]</em>: IS and OS dataframe</p></li> <li><p><span id="righthoursIS"><code>righthoursIS (df, hours)</code></span> <br> Questa funzione seleziona la fascia oraria desiderata dell’IS. <br> <strong>Inputs</strong>: <br> - <em>df</em>: dataframe da cui selezionare gli orari <br> - <em>hours</em>: lista con fascia oraria dove il mercato è più liquido <br> <strong>Outputs</strong>: <br> - <em>dff:</em> dataframe selezionato</p></li> <li><span id="righthoursOS"><code>righthoursOS (df, hours)</code></span> <br> Questa funzione seleziona la fascia oraria desiderata dell’OS. <br> <strong>Inputs</strong>: <br> - <em>df</em>: dataframe da cui selezionare gli orari <br> - <em>hours</em>: lista con fascia oraria dove sono entrambi tradabili <br> <strong>Outputs</strong>: <br> - <em>dff:</em> dataframe selezionato</li> <li><p><span id="logratio"><code>logratio (df, cHO, cLGO)</code></span> <br> Questa funzione computa il log-rapporto dei mid-prices tra HO e LGO. I prezzi sono stati riscalati affinché il confronto fosse consistente. <br> <strong>Inputs</strong>: <br> - <em>df</em>: dataframe contenente i mid-prices <br> - <em>cHO</em>: tasso di conversione in barili per HOc2 <br> - <em>cLGO</em>: tasso di conversione in barili per LGOc6 <br> <strong>Outputs</strong>: <br> - <em>logratio</em>: <em>df</em> con l’aggiunta della colonna <em>logratio</em></p></li> <li><p><span id="outliercheck"><code>outliercheck (df)</code></span> <br> Questa funzione riceve in input un vettore di dati e restituisce il vettore ripulito da eventuali outlier, gli indici dei dati non outlier e gli indici degli outlier nel vettore originale. <br> Il dato i-esimo è considerato outlier in due casi: </p> <ol><li>È minore (maggiore) del primo (terzo) quartile per più di tre volte <br> il range interquartile (IQR);</li> <li>Dista più di IQR dal dato (i-1)-esimo e questa distanza viene <br> recuperata almeno al 95% dal dato (i+1)-esimo.</li></ol> <p><strong>Inputs</strong>: <br> - <em>df</em>: dataframe da cui eliminare eventuali outliers <br> <strong>Outputs</strong>: <br> - <em>[df_OC, Outdf]</em> : dataframe ripulito e outliers rimossi</p></li> <li><p><span id="MLE_estimator"><code>MLE_estimator (logratio, dt)</code></span> <br> Questa funzione prende in input i dati e la spaziatura temporale (assumendo i dati equispaziati nelle 24h) e restituisce i parametri k, eta e sigma per un processo OU che più verosimilmente ricalca il dataset. <br> <strong>Inputs</strong>: <br> - <em>logratio</em>: colonna del dataframe contenente i log-rapporti dei mid-prices <br> - <em>dt</em>: spaziatura temporale <br> <strong>Outputs</strong>: <br> - <em>[k, eta, sigma]</em>: lista contenente i parametri del modello</p></li> <li><p><span id="costs"><code>costs (df)</code></span> <br> Questa funzione computa il costo di transazione assumendo sia il costo medio del campione IS. <br> <strong>Inputs</strong>: <br> - <em>df</em>: IS dataframe <br> <strong>Outputs</strong>: <br> - <em>cost</em>: costo di transazione</p></li> <li><p><span id="handle">Functions section</span> <br> Sezione costituita da funzioni (trascrizione in Python di function handles) utilizzate successivamente nel calcolo del long-run return (<em>mu</em>) e dei livelli (<em>u</em> e <em>d</em>) della trading band.</p></li> <li><p><span id="long_run"><code>long_run (loss, cost, theta, SIGMA, leverage, c)</code></span> <br> Questa funzione restituisce i livelli <em>u</em> e <em>d</em> che massimizzano il long-run return (<em>mu</em>), il <em>leverage</em> utilizzato e il long-run return come ‘Current function value’ (printato nel main) assumendo che i log-prices seguano la dinamica di un processo OU di parametri <em>k</em>, (<em>eta</em>=0), <em>sigma</em>. Inoltre la funzione ritorna il <em>leverage</em> utilizzato nella massimizzazione: se viene passato <em>leverage</em> = -1 verrà restituito il valore ottimale. <br> <strong>Inputs</strong>: <br> - <em>loss</em>: stop loss considerata <br> - <em>cost</em>: costo di transazione effettivo (non espresso usando <em>SIGMA</em> come unità) <br> - <em>theta</em>: parametro dipendente dai parametri di OU () <br> - <em>leverage</em>: <em>leverage</em> utilizzato, i.e. frazione di ricchezza investita nell’asset rischioso (in decimali). Se è -1 il <em>leverage</em> considerato è quello ottimo. <br> - <em>c</em>: costo di transazione effettivo usando <em>SIGMA</em> come unità) <br> <strong>Outputs</strong>: <br> - <em>[band, leverage]</em>: lista contenente la trading band e <em>leverage</em> utilizzato</p></li> <li><p><span id="generateOU"><code>generateOU (k, eta, sigma, x0, dt, N_step)</code></span> <br> Questa funzione simula un sample set di dati (traiettoria) di lunghezza <em>N_step</em> che segue la dinamica di un processo OU di parametri noti (<em>k, eta, sigma</em>). <br> <strong>Inputs</strong>: <br> - <em>k</em>: coefficiente di rilassamento <br> - <em>eta</em>: mean reverting value <br> - <em>sigma</em>: volatilità <br> - <em>x0:</em> condizione iniziale <br> - <em>dt</em>: spaziatura temporale tra due elementi consecutivi della traiettoria <br> - <em>N_step</em>: numero di passi per ogni traiettoria <br> <strong>Outputs</strong>: <br> - <em>time_serie</em>: traiettoria simulata</p></li> <li><p><span id="statisticalbootstrap"><code>statisticalbootstrap (k, eta, sigma, dt, N_sample, N_steps, x0, leverage, loss, cost, c)</code></span> <br> Questa funzione genera <em>N_sample</em> tramite la funzione <code>generateOU</code> e computa per ognuno <em>[k, eta, sigma]</em> tramite la funzione <code>MLE_estimator</code>. Con essi vengono computate, per ogni valore presente in <em>leverage</em>, le trading band ottimali. Come output si ha una lista <em>parameters</em> contenente <em>N_sample</em> della forma <em>[k, eta, sigma]</em> e una lista contenente un numero di liste pari alla lunghezza di <em>leverage</em> contenenti <em>N_sample</em> trading band ottimali. <br> <strong>Inputs</strong>: <br> - <em>k</em>: coefficiente di rilassamento <br> - <em>eta</em>: mean reverting value <br> - <em>sigma</em>: volatilità <br> - <em>dt</em>: spaziatura temporale tra due elementi consecutivi della traiettoria <br> - <em>N_sample</em>: numero di sample da generare <br> - <em>N_steps</em>: numero di passi per ogni traiettoria <br> - <em>x0</em>: condizione iniziale <br> - <em>leverage</em>: lista contenente i leverage <br> - <em>loss</em>: stop loss considerata <br> - <em>cost</em>: costo di transazione effettivo (non espresso usando <em>SIGMA</em> come unità) <br> - <em>c</em>: costo di transazione effettivo usando <em>SIGMA</em> come unità) <br> <strong>Outputs</strong>: <br> - <em>time_serie</em>: sample simulato</p></li> <li><p><span id="tradingStrategy"><code>tradingStrategy (U, D, L, leverage, W0, time_strategy, OSS_OC, cost, eta)</code></span> <br> Questa funzione simula la Trading Strategy, restituendo il log-return (normalizzato sul tempo), la ricchezza finale e gli indici e i valori in cui si apre/chiude una posizione (lunga o corta che sia). <br> <strong>Inputs</strong>: <br> - <em>U</em>: livello sopra il quale viene chiusa una posizione lunga con profitto (si considera un processo centrato in 0) <br> - <em>D</em>: livello a cui viene aperta una posizione lunga (si considera un processo centrato in 0) <br> - <em>L</em>: livello sotto il quale viene chiusa una posizione lunga con perdita (si considera un processo centrato in 0) <br> - <em>leverage</em>: leverage considerato <br> - <em>W0</em>: ricchezza iniziale <br> - <em>time_strategy</em>: tempo per cui viene attuata la strategia (frazione di anno in bus-days) <br> - <em>OSS_OC</em>: dataframe OS contenente i logratio su cui testare la strategia <br> - <em>cost</em>: costo per ogni transazione <br> - <em>eta</em>: mean reverting value <br> <strong>Outputs</strong>: <br> - <em>log_return</em>: log-return normalizzato sul tempo <br> - <em>Wt</em>: ricchezza al termine della strategia <br> - <em>check_in</em>: lista in cui sono riportati rispettivamente indici (rispetto al vettore X) e log-prices in cui viene aperta una posizione. <br> - <em>check_out</em>: lista in cui sono riportati rispettivamente indici (rispetto al vettore X) e log-prices in cui viene chiusa una posizione.</p></li> </ul> </div> </div>    
</div>
</body>

</html>
